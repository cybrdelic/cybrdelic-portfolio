<!doctype html>
<html lang="en" data-theme="light">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cybrdelic</title>
    <!-- Centralized CSS file that imports all modules -->
    <link rel="stylesheet" href="/static/css/main.css" />
    <!-- add this in your head -->
    <!-- in your head -->
    <script src="https://code.iconify.design/2/2.2.1/iconify.min.js"></script>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="/static/js/animations.js"></script>
    <script src="/static/js/documentation.js"></script>
    <script src="/static/js/projects.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.3.0/mermaid.min.js"></script>
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'neutral',
            flowchart: { curve: 'basis' }
        });
        document.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                document.documentElement.setAttribute('data-theme', savedTheme);
            }
        });
    </script>
    <style>
        .vertical-name {
            font-family: var(--font-display);
            font-weight: 800;
            font-size: var(--font-size-fluid-base);
            position: absolute;
            top: 50%;
            right: 1%;
            transform: translateY(-50%);
            writing-mode: vertical-rl;
            white-space: nowrap;
            text-orientation: mixed;
            overflow: hidden;
            opacity: 20%;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <!-- Cyberpunk corner effects - now outside terminal to avoid z-index issues -->
    <div class="corner-effect corner-top-right"></div>
    <div class="corner-effect corner-bottom-left"></div>
    <div class="scanner"></div>
    
    <div id="terminal">
        
        <nav class="nav">
            <a href="/" class="home-link">
                <div class="logo">cybrdelic</div>
            </a>
            <div class="nav-left">
                <a href="#projects" class="cmd">ls projects/</a>
                <a href="#contact" class="cmd">./contact</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/cybrdelic" target="_blank" class="cmd">git clone</a>
                <a href="#" class="cmd" id="nav-theme-toggle">
                    <span class="toggle-icon">‚òÄÔ∏è</span>
                    <span class="toggle-text">toggle theme</span>
                </a>
            </div>
        </nav>
        {% block content %}{% endblock %}
        <!-- initial text so something shows up -->
        <div class="vertical-name"></div>
    </div>
    <script src="/static/js/glitch.js"></script>
    <script>
        // Theme toggle functionality
        document.addEventListener('DOMContentLoaded', () => {
            const navThemeToggleBtn = document.getElementById('nav-theme-toggle');
            const toggleIcon = document.querySelector('.toggle-icon');
            const cornerEffects = document.querySelectorAll('.corner-effect');
            const terminal = document.getElementById('terminal');
            
            // Function to update theme
            function updateTheme(theme) {
                document.documentElement.setAttribute('data-theme', theme);
                localStorage.setItem('theme', theme);
                
                // Update toggle icon
                if (theme === 'dark') {
                    toggleIcon.textContent = 'üåô';
                } else {
                    toggleIcon.textContent = '‚òÄÔ∏è';
                }
                
                // Apply subtle animation to corner effects
                // Subtle animation when switching themes
                cornerEffects.forEach(corner => {
                    corner.style.transition = 'opacity 0.5s ease';
                    corner.style.opacity = '0.5';
                    setTimeout(() => {
                        corner.style.opacity = '0.3';
                    }, 300);
                });
            }
            
            // Initialize theme
            const savedTheme = localStorage.getItem('theme') || 'light';
            updateTheme(savedTheme);
            
            // Add click handler
            if (navThemeToggleBtn) {
                navThemeToggleBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                    updateTheme(newTheme);
                });
            }
        });
    </script>
</body>
<script>
    // scrambleText animates a scramble effect that resolves to newText over duration ms
    function scrambleText(element, newText, duration = 1000) {
        const letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        const oldText = element.textContent;
        const maxLength = Math.max(oldText.length, newText.length);
        const startTime = performance.now();

        function update() {
            const now = performance.now();
            const progress = Math.min((now - startTime) / duration, 1);
            let output = "";
            for (let i = 0; i < maxLength; i++) {
                // if progress for letter i has passed threshold, show final letter; else random
                if (i < newText.length && progress > i / maxLength) {
                    output += newText[i];
                } else {
                    output += letters[Math.floor(Math.random() * letters.length)];
                }
            }
            element.textContent = output;
            if (progress < 1) {
                requestAnimationFrame(update);
            } else {
                element.textContent = newText;
            }
        }
        update();
    }

    // morphVerticalName triggers the scramble animation if text changes
    function morphVerticalName(newText) {
        const vn = document.querySelector('.vertical-name');
        if (vn.textContent !== newText) {
            scrambleText(vn, newText, 200);
        }
    }

    document.addEventListener("DOMContentLoaded", () => {
        // use <main> as observer root if available; otherwise, viewport
        const mainContainer = document.querySelector("main") || null;
        const verticalName = document.querySelector(".vertical-name");

        const observer = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                if (entry.isIntersecting && verticalName.textContent !== entry.target.id) {
                    morphVerticalName(entry.target.id);
                }
            });
        }, { root: mainContainer, rootMargin: "-50% 0px -50% 0px", threshold: 0 });

        function observeSections() {
            const sections = document.querySelectorAll("section");
            sections.forEach(section => observer.observe(section));
        }

        observeSections();

        document.body.addEventListener("htmx:afterSwap", () => {
            observeSections();
        });
    });
</script>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const mainContainer = document.querySelector('main');
        if (!mainContainer) return;

        // Track scroll position and velocity
        let lastScrollTop = 0;
        let scrollVelocity = 0;
        let scrollTimeout;

        mainContainer.addEventListener('scroll', () => {
            // Clear any pending timeout
            clearTimeout(scrollTimeout);

            const currentScrollTop = mainContainer.scrollTop;
            scrollVelocity = currentScrollTop - lastScrollTop;
            lastScrollTop = currentScrollTop;

            // Set a timeout to detect when scrolling has stopped
            scrollTimeout = setTimeout(() => {
                // Only apply snapping behavior if scrolling has almost stopped
                // and we're not in the middle of a section
                if (Math.abs(scrollVelocity) < 5) {
                    const sections = document.querySelectorAll('section');

                    // Find the current section and its boundaries
                    let currentSection = null;
                    let closestDistance = Infinity;

                    sections.forEach(section => {
                        const rect = section.getBoundingClientRect();
                        const distance = Math.abs(rect.top);

                        if (distance < closestDistance) {
                            closestDistance = distance;
                            currentSection = section;
                        }
                    });

                    // If we're very close to the start of a section, snap to it
                    if (currentSection && closestDistance < 50) {
                        currentSection.scrollIntoView({ behavior: 'smooth' });
                    }
                }
            }, 150); // Wait for scrolling to finish
        });
    });
</script>

</html>
